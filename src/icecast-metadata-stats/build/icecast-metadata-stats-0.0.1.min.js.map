{"version":3,"sources":["webpack://IcecastMetadataStats/./node_modules/icecast-metadata-js/src/IcecastMetadataQueue.js","webpack://IcecastMetadataStats/./node_modules/icecast-metadata-js/src/IcecastMetadataReader.js","webpack://IcecastMetadataStats/./node_modules/icecast-metadata-js/src/IcecastReadableStream.js","webpack://IcecastMetadataStats/./node_modules/icecast-metadata-js/src/MetadataParser/DualMetadataParser.js","webpack://IcecastMetadataStats/./node_modules/icecast-metadata-js/src/MetadataParser/IcyMetadataParser.js","webpack://IcecastMetadataStats/./node_modules/icecast-metadata-js/src/MetadataParser/MetadataParser.js","webpack://IcecastMetadataStats/./node_modules/icecast-metadata-js/src/MetadataParser/OggMetadataParser.js","webpack://IcecastMetadataStats/./node_modules/icecast-metadata-js/src/MetadataParser/Stats.js","webpack://IcecastMetadataStats/webpack/bootstrap","webpack://IcecastMetadataStats/webpack/runtime/compat get default export","webpack://IcecastMetadataStats/webpack/runtime/define property getters","webpack://IcecastMetadataStats/webpack/runtime/hasOwnProperty shorthand","webpack://IcecastMetadataStats/./src/IcecastMetadataStats.js"],"names":["noOp","module","exports","icyBr","onMetadataUpdate","onMetadataEnqueue","this","_icyBr","_onMetadataUpdate","_onMetadataEnqueue","_isInitialMetadata","_metadataQueue","map","_timeoutId","rest","metadata","stats","timestampOffset","timestamp","_enqueueMetadata","getTimeByBytes","currentStreamPosition","bytesRead","forEach","i","clearTimeout","metadataPayload","push","_dequeueMetadata","setTimeout","shift","MetadataParser","IcyMetadataParser","OggMetadataParser","DualMetadataParser","metadataTypes","hasIcy","includes","hasOgg","_metadataParser","string","parseIcyMetadata","icyMetaInt","chunk","iterator","readAll","asyncIterator","asyncReadAll","IcecastMetadataReader","IcecastReadableStream","response","onStream","icecast","_readableStream","ReadableStream","controller","parseInt","headers","get","async","value","enqueue","stream","body","close","_icecast","e","name","readableStream","reader","getReader","Symbol","next","read","params","_oggMetadataParser","_icyMetadataParser","oggValue","icyDetectionTimeout","super","_icyMetaInt","_icyDetectionTimeout","_generator","_icyParser","_hasIcyMetadata","_remainingData","_getStream","_getMetadataLength","_getMetadata","Infinity","metadataString","metadataRegex","metadataElement","match","RegExp","_logError","METADATA_SEARCH","startTime","Date","now","metaInt","_buffer","_concatBuffers","_readData","detectMetadata","length","_onMetadataFailed","_stats","currentStreamBytesRemaining","_sendStream","_getNextValue","addMetadataLengthBytes","currentMetadataBytesRemaining","addMetadataBytes","_sendMetadata","_decoder","decode","Decoder","TextDecoder","Stats","_currentPosition","Uint8Array","_onStream","_onMetadata","onMetadata","onMetadataFailed","_onError","onError","_enableLogging","enableLogging","_onStreamPromise","Promise","resolve","_onMetadataPromise","_passThroughParser","buf1","buf2","result","set","messages","console","warn","reduce","acc","message","addStreamBytes","streamPayload","minLength","subarray","addBytes","data","addCurrentBytesRemaining","_oggParser","_hasOggPage","codecMatcher","_identifyCodec","offset","DataView","from","buffer","getUint32","matchString","bytes","String","fromCharCode","syncBytes","_totalBytesRead","_currentBytesRemaining","baseOggPage","oggPageSegments","octet","_matchBytes","regex","_readVorbisComment","vendorStringLength","_getUint32","vendorString","commentListLength","comments","commentLength","comment","delimiter","indexOf","key","toUpperCase","val","VENDOR_STRING","_streamBytesRead","_metadataLengthBytesRead","_metadataBytesRead","_currentStreamBytesRemaining","_currentMetadataBytesRemaining","totalBytesRead","streamBytesRead","metadataLengthBytesRead","metadataBytesRead","currentBytesRemaining","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","n","getter","__esModule","d","a","definition","o","Object","defineProperty","enumerable","obj","prop","prototype","hasOwnProperty","call","STOPPED","FETCHING","p","WeakMap","icyController","icyFetchStatus","oggController","oggFetchStatus","icestatsEndpoint","icestatsController","icestatsFetchStatus","statsEndpoint","statsController","statsFetchStatus","nextsongsEndpoint","nextsongsController","nextsongsFetchStatus","sevenhtmlEndpoint","sevenhtmlController","sevenhtmlFetchStatus","streamEndpoint","sources","interval","onStats","onStatsFetch","state","intervalId","fetchStats","getStreamMetadata","IcecastMetadataStats","endpoint","options","serverPath","split","slice","join","AbortController","xml","serialize","element","children","Number","isNaN","innerHTML","json","child","nodeName","Array","isArray","DOMParser","parseFromString","deserialize","fetch","then","setInterval","clearInterval","abort","oldState","promises","getIcestats","getSevenhtml","getStats","getNextsongs","getIcyMetadata","getOggMetadata","all","stat","status","mapper","res","icestats","text","s","groups","StreamTitle","currentListeners","peakListeners","maxListeners","bitrate","serverListeners","sevenhtml","xml2Json","SHOUTCASTSERVER","STREAMSTATS","NEXTSONGS","nextsongs","metadataType","startReading","method","signal","ok","Error","catch","finally"],"mappings":"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","file":"icecast-metadata-stats-0.0.1.min.js","sourcesContent":["/* Copyright 2020 Ethan Halsall\n    This file is part of icecast-metadata-js.\n\n    icecast-metadata-js free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    icecast-metadata-js distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nconst noOp = () => {};\n\nclass IcecastMetadataQueue {\n  /**\n   * @description Schedules updates up to the millisecond for Icecast Metadata from the response body of an Icecast stream mountpoint\n   * @description The accuracy of metadata updates is a direct relationship of the icyMetaInt\n   * @param {Object} IcecastMetadataQueue constructor parameter\n   * @param {number} [IcecastMetadataQueue.icyBr] Bitrate of audio stream used to increase accuracy when to updating metadata\n   * @param {onMetadataUpdate} [IcecastMetadataQueue.onMetadataUpdate] Callback executed when metadata is scheduled to update\n   * @param {onMetadataEnqueue} [IcecastMetadataQueue.onMetadataEnqueue] Callback executed when metadata is enqueued\n   *\n   * @callback onMetadataUpdate\n   * @param {Object} metadata Object containing all metadata received.\n   * @param {string} [metadata.StreamTitle] Title of the metadata update.\n   * @param {string} [metadata.StreamUrl] Url (usually album art) of the metadata update.\n   * @param {number} timestampOffset Total time buffered when the metadata was added\n   * @param {number} timestamp Current time of the audio player when the metadata was added\n   *\n   * @callback onMetadataEnqueue\n   * @param {Object} metadata Object containing all metadata received.\n   * @param {string} [metadata.StreamTitle] Title of the metadata update.\n   * @param {string} [metadata.StreamUrl] Url (usually album art) of the metadata update.\n   * @param {number} timestampOffset Total time buffered when the metadata was added\n   * @param {number} timestamp Current time of the audio player when the metadata was added\n   *\n   */\n  constructor({ icyBr, onMetadataUpdate = noOp, onMetadataEnqueue = noOp }) {\n    this._icyBr = icyBr;\n    this._onMetadataUpdate = onMetadataUpdate;\n    this._onMetadataEnqueue = onMetadataEnqueue;\n    this._isInitialMetadata = true;\n    this._metadataQueue = [];\n  }\n\n  /**\n   * @description Returns the metadata queued for updates\n   * @type {{metadata: string, time: number}[]} Queued metadata\n   */\n  get metadataQueue() {\n    return this._metadataQueue.map(({ _timeoutId, ...rest }) => rest);\n  }\n\n  /**\n   *\n   * @param {object} metadata Metadata object returned from IcecastMetadataReader\n   * @param {number} timestampOffset Total buffered audio in seconds\n   * @param {number} [timestamp] Current time in the audio player\n   */\n  addMetadata({ metadata, stats }, timestampOffset, timestamp = 0) {\n    /**\n     * Metadata time is derived from the total number of stream bytes read\n     * since the latest buffer input. The buffer offset should be the total\n     * seconds of audio in the player buffer when the metadata was read.\n     */\n    this._enqueueMetadata(\n      metadata,\n      timestampOffset,\n      timestamp + this.getTimeByBytes(stats.currentStreamPosition)\n    );\n  }\n\n  /**\n   * @description Calculates audio stream length based on bitrate\n   * @param {number} bytesRead Number of bytes\n   * @type {number} Seconds\n   */\n  getTimeByBytes(bytesRead) {\n    return this._icyBr ? bytesRead / (this._icyBr * 125) : 0;\n  }\n\n  /**\n   * @description Clears all metadata updates and empties the queue\n   */\n  purgeMetadataQueue() {\n    this._metadataQueue.forEach((i) => clearTimeout(i._timeoutId));\n    this._metadataQueue = [];\n  }\n\n  _enqueueMetadata(metadata, timestampOffset, timestamp) {\n    const metadataPayload = {\n      metadata,\n      timestampOffset,\n      timestamp,\n    };\n\n    this._metadataQueue.push(metadataPayload);\n    this._onMetadataEnqueue(metadata, timestampOffset, timestamp);\n\n    if (this._isInitialMetadata) {\n      this._dequeueMetadata();\n      this._isInitialMetadata = false;\n    } else {\n      metadataPayload._timeoutId = setTimeout(() => {\n        this._dequeueMetadata();\n      }, (timestampOffset - timestamp) * 1000); // trigger timeout relative to play position\n    }\n  }\n\n  _dequeueMetadata() {\n    const {\n      metadata,\n      timestampOffset,\n      timestamp,\n    } = this._metadataQueue.shift();\n    this._onMetadataUpdate(metadata, timestampOffset, timestamp);\n  }\n}\n\nmodule.exports = IcecastMetadataQueue;\n","/* Copyright 2020 Ethan Halsall\n    This file is part of icecast-metadata-js.\n\n    icecast-metadata-js free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    icecast-metadata-js distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nconst MetadataParser = require(\"./MetadataParser/MetadataParser\");\nconst IcyMetadataParser = require(\"./MetadataParser/IcyMetadataParser\");\nconst OggMetadataParser = require(\"./MetadataParser/OggMetadataParser\");\nconst DualMetadataParser = require(\"./MetadataParser/DualMetadataParser\");\n\nclass IcecastMetadataReader {\n  /**\n   * @description Splits Icecast raw response into stream bytes and metadata key / value pairs.\n   * @param {number} IcecastMetadataReader.icyMetaInt Interval in bytes of metadata updates returned by the Icecast server\n   * @param {number} IcecastMetadataReader.icyDetectionTimeout Duration in milliseconds to search for metadata if icyMetaInt isn't passed in\n   * @param {Array} IcecastMetadataReader.metadataTypes Types of metadata to capture: \"icy\" and/or \"ogg\"\n   *\n   * @callback onMetadata\n   * @param {object} value Object containing Metadata and Statistics\n   * @param {object} metadata Object containing the metadata received.\n   * @param {string} [metadata.StreamTitle] (ICY) Title of the metadata update.\n   * @param {string} [metadata.StreamUrl] (ICY) Url (usually album art) of the metadata update.\n   * @param {string} [metadata.TITLE] (OGG) Url Title of the metadata update.\n   * @param {object} stats Object containing statistics on how many bytes were read and the current read position.\n   *\n   * @callback onStream\n   * @param {object} value Object containing Stream data and Statistics\n   * @param {Uint8Array} stream Object containing the stream buffer.\n   * @param {object} stats Object containing statistics on how many bytes were read and the current read position.\n   *\n   * @callback onMetadataFailed Called when metadata detection has failed and no metadata will be returned\n   * @param {string} metadataType Metadata type that failed (\"icy\" or \"ogg\")\n   *\n   * @callback onError Called when an error is encounted\n   * @param {string} message Error message\n   */\n  constructor({ metadataTypes = [\"icy\"], ...rest } = {}) {\n    const hasIcy = metadataTypes.includes(\"icy\");\n    const hasOgg = metadataTypes.includes(\"ogg\");\n\n    if (hasIcy && hasOgg) this._metadataParser = new DualMetadataParser(rest);\n    else if (hasOgg) this._metadataParser = new OggMetadataParser(rest);\n    else if (hasIcy) this._metadataParser = new IcyMetadataParser(rest);\n    else this._metadataParser = new MetadataParser(rest);\n  }\n\n  /**\n   * @description Parses an ICY metadata string into key value pairs.\n   * @param {string} metadataString ICY formatted metadata string. (i.e. \"StreamTitle='A Title';\")\n   * @returns {object} Parsed metadata key value pairs. (i.e. {StreamTitle: \"A Title\"})\n   */\n  static parseIcyMetadata(string) {\n    return IcyMetadataParser.parseIcyMetadata(string);\n  }\n\n  /**\n   * @description Gets the ICY metadata interval for this instance.\n   * @returns {number} ICY metadata interval in bytes.\n   */\n  get icyMetaInt() {\n    return this._metadataParser.icyMetaInt;\n  }\n\n  /**\n   * @description Returns an iterator that yields stream or metadata.\n   * @param {Uint8Array} chunk Next chunk of data to read\n   * @returns {Iterator} Iterator that operates over a raw icecast response.\n   * @yields {object} Object containing stream or metadata.\n   */\n  *iterator(chunk) {\n    yield* this._metadataParser.iterator(chunk);\n  }\n\n  /**\n   * @description Reads all data in the passed in chunk and calls the onStream and onMetadata callbacks.\n   * @param {Uint8Array} chunk Next chunk of data to read\n   */\n  readAll(chunk) {\n    this._metadataParser.readAll(chunk);\n  }\n\n  /**\n   * @description Returns an async iterator that yields stream or metadata and awaits the onStream and onMetadata callbacks.\n   * @param {Uint8Array} chunk Next chunk of data to read\n   * @returns {IterableIterator} Iterator that operates over a raw icecast response.\n   * @yields {object} Object containing stream or metadata.\n   */\n  async *asyncIterator(chunk) {\n    return yield* this._metadataParser.asyncIterator(chunk);\n  }\n\n  /**\n   * @description Reads all data in the chunk and awaits the onStream and onMetadata callbacks.\n   * @param {Uint8Array} chunk Next chunk of data to read\n   */\n  async asyncReadAll(chunk) {\n    return this._metadataParser.asyncReadAll(chunk);\n  }\n}\n\nmodule.exports = IcecastMetadataReader;\n","/* Copyright 2020 Ethan Halsall\n    This file is part of icecast-metadata-js.\n\n    icecast-metadata-js free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    icecast-metadata-js distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nconst IcecastMetadataReader = require(\"./IcecastMetadataReader\");\n\nconst noOp = () => {};\n\n/**\n * @description Browser ReadableStream wrapper for IcecastMetadataReader\n */\nclass IcecastReadableStream {\n  /**\n   * @param {ReadableStream} response ReadableStream for raw Icecast response data\n   * @param {object} options Configuration options for IcecastMetadataReader\n   * @see IcecastMetadataReader for information on the options parameter\n   */\n  constructor(response, { icyMetaInt, onStream = noOp, ...rest }) {\n    let icecast;\n\n    this._readableStream = new ReadableStream({\n      async start(controller) {\n        icecast = new IcecastMetadataReader({\n          ...rest,\n          icyMetaInt:\n            parseInt(response.headers.get(\"Icy-MetaInt\")) || icyMetaInt,\n          onStream: async (value) => {\n            controller.enqueue(value.stream);\n            return onStream(value);\n          },\n        });\n\n        for await (const chunk of IcecastReadableStream.asyncIterator(\n          response.body\n        )) {\n          await icecast.asyncReadAll(chunk);\n        }\n\n        controller.close();\n      },\n    });\n\n    this._icecast = icecast;\n  }\n\n  /**\n   * @returns Icecast Metadata Interval if it is present on this stream\n   */\n  get icyMetaInt() {\n    return this._icecast.icyMetaInt;\n  }\n\n  /**\n   * @returns The ReadableStream instance\n   */\n  get readableStream() {\n    return this._readableStream;\n  }\n\n  /**\n   * @description Starts reading from the response and processing stream and metadata.\n   */\n  async startReading() {\n    try {\n      for await (const i of IcecastReadableStream.asyncIterator(\n        this._readableStream\n      )) {\n      }\n    } catch (e) {\n      if (e.name !== \"AbortError\") throw e;\n    }\n  }\n\n  /**\n   * @description Wraps a ReadableStream as an Async Iterator.\n   * @param {ReadableStream} readableStream ReadableStream to convert to AsyncIterator\n   * @returns {Symbol.asyncIterator} Async Iterator that wraps the ReadableStream\n   */\n  static asyncIterator(readableStream) {\n    const reader = readableStream.getReader();\n    return {\n      [Symbol.asyncIterator]: () => ({\n        next: () => reader.read(),\n      }),\n    };\n  }\n}\n\nmodule.exports = IcecastReadableStream;\n","/* Copyright 2020 Ethan Halsall\n    This file is part of icecast-metadata-js.\n\n    icecast-metadata-js free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    icecast-metadata-js distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nconst IcyMetadataParser = require(\"./IcyMetadataParser\");\nconst OggMetadataParser = require(\"./OggMetadataParser\");\n\n/**\n * @description Parses ICY and OGG metadata from an Icecast stream\n * @protected\n * @see IcecastMetadataReader\n */\n\nclass DualMetadataParser {\n  constructor(params) {\n    const { onStream, ...rest } = params;\n    this._oggMetadataParser = new OggMetadataParser(params);\n    this._icyMetadataParser = new IcyMetadataParser(rest);\n  }\n\n  get icyMetaInt() {\n    return this._icyMetadataParser.icyMetaInt;\n  }\n\n  *iterator(chunk) {\n    for (const value of this._icyMetadataParser.iterator(chunk)) {\n      if (value.stream) {\n        yield* this._oggMetadataParser.iterator(value.stream);\n      } else {\n        yield value;\n      }\n    }\n  }\n\n  readAll(chunk) {\n    for (const value of this._icyMetadataParser.iterator(chunk)) {\n      if (value.stream) {\n        this._oggMetadataParser.readAll(value.stream);\n      }\n    }\n  }\n\n  async *asyncIterator(chunk) {\n    for await (const value of this._icyMetadataParser.asyncIterator(chunk)) {\n      if (value.stream) {\n        for await (const oggValue of this._oggMetadataParser.asyncIterator(\n          value.stream\n        )) {\n          yield oggValue;\n        }\n      } else {\n        yield value;\n      }\n    }\n  }\n\n  async asyncReadAll(chunk) {\n    for await (const value of this._icyMetadataParser.iterator(chunk)) {\n      if (value.stream) {\n        await this._oggMetadataParser.asyncReadAll(value.stream);\n      }\n    }\n  }\n}\n\nmodule.exports = DualMetadataParser;\n","/* Copyright 2020 Ethan Halsall\n    This file is part of icecast-metadata-js.\n\n    icecast-metadata-js free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    icecast-metadata-js distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nconst MetadataParser = require(\"./MetadataParser\");\n\n/**\n * @description Parses ICY metadata from an Icecast stream\n * @protected\n * @see IcecastMetadataReader\n */\n\nclass IcyMetadataParser extends MetadataParser {\n  constructor({ icyMetaInt, icyDetectionTimeout = 2000, ...rest }) {\n    super(rest);\n\n    this._icyMetaInt = icyMetaInt;\n    this._icyDetectionTimeout = icyDetectionTimeout;\n\n    this._generator = this._icyParser();\n    this._generator.next();\n  }\n\n  *_icyParser() {\n    if (yield* this._hasIcyMetadata()) {\n      do {\n        this._remainingData = this._icyMetaInt;\n        yield* this._getStream();\n        yield* this._getMetadataLength();\n        if (this._remainingData) yield* this._getMetadata();\n      } while (true);\n    }\n\n    this._remainingData = Infinity;\n    yield* this._getStream();\n  }\n\n  static parseIcyMetadata(metadataString) {\n    /**\n     * Metadata is a string of key='value' pairs delimited by a semicolon.\n     * The string is a fixed length and any unused bytes at the end are 0x00.\n     * i.e. \"StreamTitle='The Stream Title';StreamUrl='https://example.com';\\0\\0\\0\\0\\0\\0\"\n     */\n\n    const metadataRegex = /(?<key>[^\\0]+?)='(?<val>[^\\0]*?)(;$|';|'$|$)/;\n    const metadata = {};\n\n    // [{key: \"StreamTitle\", val: \"The Stream Title\"}, {key: \"StreamUrl\", val: \"https://example.com\"}]\n    for (const metadataElement of metadataString.match(\n      new RegExp(metadataRegex, \"g\")\n    ) || []) {\n      const match = metadataElement.match(metadataRegex);\n      if (match) metadata[match[\"groups\"][\"key\"]] = match[\"groups\"][\"val\"];\n    }\n\n    // {StreamTitle: \"The Stream Title\", StreamUrl: \"https://example.com\"}\n    return metadata;\n  }\n\n  get icyMetaInt() {\n    return this._icyMetaInt;\n  }\n\n  *_hasIcyMetadata() {\n    if (this._icyMetaInt > 0) return true;\n    if (!this._icyDetectionTimeout) return false;\n\n    this._logError(\n      \"Passed in Icy-MetaInt is invalid. Attempting to detect ICY Metadata.\",\n      \"See https://github.com/eshaz/icecast-metadata-js for information on how to properly request ICY Metadata.\"\n    );\n\n    // prettier-ignore\n    const METADATA_SEARCH = [null,83,116,114,101,97,109,84,105,116,108,101,61]; // StreamTitle=\n    const startTime = Date.now();\n    let metaInt = 0;\n\n    while (startTime + this._icyDetectionTimeout > Date.now()) {\n      this._buffer = MetadataParser._concatBuffers(\n        this._buffer,\n        yield* this._readData()\n      );\n\n      // search for metadata\n      detectMetadata: while (\n        metaInt <\n        this._buffer.length - METADATA_SEARCH.length\n      ) {\n        for (let i = 1; i < METADATA_SEARCH.length; i++) {\n          if (this._buffer[i + metaInt] !== METADATA_SEARCH[i]) {\n            metaInt++;\n            continue detectMetadata;\n          }\n        }\n\n        // found metadata\n        // prettier-ignore\n        this._logError(`Found ICY Metadata! Setting Icy-MetaInt to ${metaInt}.`);\n        this._icyMetaInt = metaInt;\n\n        return true;\n      }\n    }\n\n    // prettier-ignore\n    this._logError(\n      \"ICY Metadata not detected, but continuing anyway. Audio errors will occur if there is ICY metadata.\",\n      `Searched ${this._buffer.length} bytes for ${(Date.now() - startTime) / 1000} seconds.`,\n      \"Try increasing the `icyDetectionTimeout` value if ICY metadata is present in the stream.\"\n    );\n    this._onMetadataFailed(\"icy\");\n\n    return false;\n  }\n\n  *_getStream() {\n    this._stats.currentStreamBytesRemaining = this._remainingData;\n\n    while (this._remainingData) {\n      yield* this._sendStream(yield* super._getNextValue());\n    }\n  }\n\n  *_getMetadataLength() {\n    this._remainingData = 1;\n\n    do {\n      this._remainingData = (yield* this._getNextValue())[0] * 16;\n    } while (this._remainingData === 1);\n\n    this._stats.addMetadataLengthBytes(1);\n  }\n\n  *_getMetadata() {\n    this._stats.currentMetadataBytesRemaining = this._remainingData;\n\n    const metadata = yield* this._getNextValue(this._remainingData);\n    this._stats.addMetadataBytes(metadata.length);\n\n    yield* this._sendMetadata(\n      IcyMetadataParser.parseIcyMetadata(this._decoder.decode(metadata))\n    );\n  }\n}\n\nmodule.exports = IcyMetadataParser;\n","/* Copyright 2020 Ethan Halsall\n    This file is part of icecast-metadata-js.\n\n    icecast-metadata-js free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    icecast-metadata-js distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nconst Decoder = require(\"util\").TextDecoder || TextDecoder;\nconst Stats = require(\"./Stats\");\n\nconst noOp = () => {};\n\n/**\n * @description Passthrough parser\n * @protected\n * @see IcecastMetadataReader\n */\n\nclass MetadataParser {\n  constructor(params) {\n    this._remainingData = 0;\n    this._currentPosition = 0;\n    this._buffer = new Uint8Array(0);\n    this._stats = new Stats();\n    this._decoder = new Decoder(\"utf-8\");\n\n    this._onStream = params.onStream || noOp;\n    this._onMetadata = params.onMetadata || noOp;\n    this._onMetadataFailed = params.onMetadataFailed || noOp;\n    this._onError = params.onError || noOp;\n    this._enableLogging = params.enableLogging || false;\n\n    this._onStreamPromise = Promise.resolve();\n    this._onMetadataPromise = Promise.resolve();\n    this._generator = this._passThroughParser();\n    this._generator.next();\n  }\n\n  *_passThroughParser() {\n    this._remainingData = Infinity;\n    while (true) {\n      yield* this._sendStream(yield* this._getNextValue());\n    }\n  }\n\n  static _concatBuffers(buf1, buf2) {\n    const result = new Uint8Array(buf1.length + buf2.length);\n    result.set(buf1);\n    result.set(buf2, buf1.length);\n    return result;\n  }\n\n  *iterator(chunk) {\n    for (\n      let i = this._generator.next(chunk);\n      i.value;\n      i = this._generator.next()\n    ) {\n      yield i.value;\n    }\n  }\n\n  readAll(chunk) {\n    for (\n      let i = this._generator.next(chunk);\n      i.value;\n      i = this._generator.next()\n    ) {}\n  }\n\n  async *asyncIterator(chunk) {\n    for (\n      let i = this._generator.next(chunk);\n      i.value;\n      i = this._generator.next()\n    ) {\n      await this._onStreamPromise;\n      await this._onMetadataPromise;\n      yield i.value;\n    }\n  }\n\n  async asyncReadAll(chunk) {\n    for (\n      let i = this._generator.next(chunk);\n      i.value;\n      i = this._generator.next()\n    ) {\n      await this._onStreamPromise;\n      await this._onMetadataPromise;\n    }\n  }\n\n  _logError(...messages) {\n    if (this._enableLogging) {\n      console.warn(\n        \"icecast-metadata-js\",\n        messages.reduce((acc, message) => acc + \"\\n  \" + message, \"\")\n      );\n    }\n    this._onError(...messages);\n  }\n\n  *_sendStream(stream) {\n    this._stats.addStreamBytes(stream.length);\n\n    const streamPayload = { stream, stats: this._stats.stats };\n\n    this._onStreamPromise = this._onStream(streamPayload);\n    yield streamPayload;\n  }\n\n  *_sendMetadata(metadata) {\n    const metadataPayload = {\n      metadata,\n      stats: this._stats.stats,\n    };\n\n    this._onMetadataPromise = this._onMetadata(metadataPayload);\n    yield metadataPayload;\n  }\n\n  *_getNextValue(minLength = 0) {\n    if (this._currentPosition === this._buffer.length) {\n      this._buffer = yield* this._readData();\n      this._currentPosition = 0;\n    }\n\n    while (this._buffer.length - this._currentPosition < minLength) {\n      this._buffer = MetadataParser._concatBuffers(\n        this._buffer,\n        yield* this._readData()\n      );\n    }\n\n    const value = this._buffer.subarray(\n      this._currentPosition,\n      (minLength || this._remainingData) + this._currentPosition\n    );\n\n    this._stats.addBytes(value.length);\n    this._remainingData =\n      value.length < this._remainingData\n        ? this._remainingData - value.length\n        : 0;\n\n    this._currentPosition += value.length;\n\n    return value;\n  }\n\n  *_readData() {\n    let data;\n\n    do {\n      data = yield; // if out of data, accept new data in the .next() call\n    } while (!data || data.length === 0);\n\n    this._stats.addCurrentBytesRemaining(data.length);\n    return data;\n  }\n}\n\nmodule.exports = MetadataParser;\n","/* Copyright 2020 Ethan Halsall\n    This file is part of icecast-metadata-js.\n\n    icecast-metadata-js free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    icecast-metadata-js distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nconst MetadataParser = require(\"./MetadataParser\");\n\n/**\n * @description Parses OGG metadata from an Icecast stream\n * @protected\n * @see IcecastMetadataReader\n */\nclass OggMetadataParser extends MetadataParser {\n  constructor(params) {\n    super(params);\n\n    this._generator = this._oggParser();\n    this._generator.next();\n  }\n\n  *_oggParser() {\n    if (yield* this._hasOggPage()) {\n      const codecMatcher = yield* this._identifyCodec();\n      if (codecMatcher) {\n        while (yield* this._hasOggPage()) {\n          yield* this._getMetadata(codecMatcher);\n          yield* this._getStream();\n        }\n      }\n    }\n\n    this._remainingData = Infinity;\n    yield* this._getStream();\n  }\n\n  _getUint32(data, offset = 0) {\n    return new DataView(\n      Uint8Array.from([...data.subarray(offset, offset + 4)]).buffer\n    ).getUint32(0, true);\n  }\n\n  _matchBytes(matchString, bytes) {\n    return String.fromCharCode(...bytes).match(matchString);\n  }\n\n  *_hasOggPage() {\n    // Bytes (1-4 of 28)\n    // Frame sync (must equal OggS): `AAAAAAAA|AAAAAAAA|AAAAAAAA|AAAAAAAA`:\n    // Byte (6 of 28)\n    // * `00000...`: All zeros\n    let syncBytes = [];\n    while (syncBytes.length <= 65307) {\n      // max ogg page size\n      const bytes = yield* super._getNextValue(5); // Sync with OGG page without sending stream data\n      if (\n        bytes[0] === 0x4f &&\n        bytes[1] === 0x67 &&\n        bytes[2] === 0x67 &&\n        bytes[3] === 0x53 &&\n        !(bytes[5] & 0b11111000)\n      ) {\n        this._currentPosition -= 5;\n        this._remainingData += 5;\n        this._stats._totalBytesRead -= 5;\n        this._stats._currentBytesRemaining += 5;\n        break;\n      }\n      syncBytes.push(bytes[0]);\n\n      this._currentPosition -= 4;\n      this._stats._totalBytesRead -= 4;\n      this._stats._currentBytesRemaining += 4;\n    }\n\n    if (syncBytes.length) yield* this._sendStream(Uint8Array.from(syncBytes));\n\n    if (syncBytes.length > 65307) {\n      this._logError(\n        \"This stream is not an OGG stream. No OGG metadata will be returned.\",\n        \"See https://github.com/eshaz/icecast-metadata-js for information on OGG metadata.\"\n      );\n      this._onMetadataFailed(\"ogg\");\n      return false;\n    }\n\n    const baseOggPage = yield* this._getNextValue(27);\n    // Byte (27 of 28)\n    // * `JJJJJJJJ`: Number of page segments in the segment table\n    const oggPageSegments = yield* this._getNextValue(baseOggPage[26]);\n\n    this._remainingData = oggPageSegments.reduce(\n      (acc, octet) => acc + octet,\n      0\n    );\n    return true;\n  }\n\n  *_identifyCodec() {\n    const data = yield* this._getNextValue(8);\n\n    yield* this._getStream();\n\n    if (this._matchBytes(/\\x7fFLAC/, data.subarray(0, 5))) {\n      return { regex: /^[\\x84|\\x04]/, length: 4 };\n    } else if (this._matchBytes(/OpusHead/, data.subarray(0, 8))) {\n      return { regex: /OpusTags/, length: 8 };\n    } else if (this._matchBytes(/\\x01vorbis/, data.subarray(0, 7))) {\n      return { regex: /\\x03vorbis/, length: 7 };\n    }\n  }\n\n  *_getMetadata({ regex, length }) {\n    if (this._matchBytes(regex, yield* this._getNextValue(length))) {\n      yield* this._sendMetadata(yield* this._readVorbisComment());\n    }\n  }\n\n  *_getStream() {\n    while (this._remainingData) {\n      yield* this._getNextValue();\n    }\n  }\n\n  *_getNextValue(length) {\n    const value = yield* super._getNextValue(length);\n\n    yield* this._sendStream(value);\n    return value;\n  }\n\n  *_readData() {\n    const data = yield* super._readData();\n    this._stats.currentStreamBytesRemaining = data.length;\n    return data;\n  }\n\n  *_readVorbisComment() {\n    /*\n    1) [vendor_length] = read an unsigned integer of 32 bits\n    2) [vendor_string] = read a UTF-8 vector as [vendor_length] octets\n    3) [user_comment_list_length] = read an unsigned integer of 32 bits\n    4) iterate [user_comment_list_length] times {\n       5) [length] = read an unsigned integer of 32 bits\n       6) this iteration's user comment = read a UTF-8 vector as [length] octets\n    }\n    7) [framing_bit] = read a single bit as boolean\n    8) if ( [framing_bit] unset or end of packet ) then ERROR\n    9) done.\n    */\n    const vendorStringLength = this._getUint32(yield* this._getNextValue(4));\n    this._stats.addMetadataBytes(4);\n\n    const vendorString = this._decoder.decode(\n      yield* this._getNextValue(vendorStringLength)\n    );\n    this._stats.addMetadataBytes(vendorStringLength);\n\n    const commentListLength = this._getUint32(yield* this._getNextValue(4));\n    this._stats.addMetadataBytes(4);\n\n    const comments = [];\n    for (let i = 0; i < commentListLength; i++) {\n      const commentLength = yield* this._getNextValue(4);\n      this._stats.addMetadataBytes(4);\n\n      comments.push(yield* this._getNextValue(this._getUint32(commentLength)));\n      this._stats.addMetadataBytes(comments[comments.length - 1].length);\n    }\n\n    this._stats.currentMetadataBytesRemaining = 0;\n\n    return comments.reduce(\n      (metadata, comment) => {\n        const delimiter = comment.indexOf(0x3d);\n        // prettier-ignore\n        const key = String.fromCharCode(...comment.subarray(0, delimiter)).toUpperCase();\n        const val = this._decoder.decode(comment.subarray(delimiter + 1));\n\n        metadata[key] = metadata[key] ? `${metadata[key]}; ${val}` : val;\n        return metadata;\n      },\n      { VENDOR_STRING: vendorString }\n    );\n  }\n}\n\nmodule.exports = OggMetadataParser;\n","/* Copyright 2020 Ethan Halsall\n    This file is part of icecast-metadata-js.\n\n    icecast-metadata-js free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    icecast-metadata-js distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nclass Stats {\n  constructor() {\n    this._totalBytesRead = 0;\n    this._streamBytesRead = 0;\n    this._metadataLengthBytesRead = 0;\n    this._metadataBytesRead = 0;\n\n    this._currentBytesRemaining = 0;\n    this._currentStreamBytesRemaining = 0;\n    this._currentMetadataBytesRemaining = 0;\n  }\n\n  get stats() {\n    return {\n      totalBytesRead: this._totalBytesRead,\n      streamBytesRead: this._streamBytesRead,\n      metadataLengthBytesRead: this._metadataLengthBytesRead,\n      metadataBytesRead: this._metadataBytesRead,\n      currentBytesRemaining: this._currentBytesRemaining,\n      currentStreamBytesRemaining: this._currentStreamBytesRemaining,\n      currentMetadataBytesRemaining: this._currentMetadataBytesRemaining,\n    };\n  }\n\n  set currentStreamBytesRemaining(bytes) {\n    this._currentStreamBytesRemaining += bytes;\n  }\n\n  set currentMetadataBytesRemaining(bytes) {\n    this._currentMetadataBytesRemaining = bytes;\n  }\n\n  addBytes(bytes) {\n    this._totalBytesRead += bytes;\n    this._currentBytesRemaining -= bytes;\n  }\n\n  addStreamBytes(bytes) {\n    this._streamBytesRead += bytes;\n    this._currentStreamBytesRemaining -= bytes;\n  }\n\n  addMetadataLengthBytes(bytes) {\n    this._metadataLengthBytesRead += bytes;\n  }\n\n  addMetadataBytes(bytes) {\n    this._metadataBytesRead += bytes;\n    this._currentMetadataBytesRemaining -= bytes;\n  }\n\n  addCurrentBytesRemaining(bytes) {\n    this._currentBytesRemaining += bytes;\n  }\n}\n\nmodule.exports = Stats;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","/**\n * @license\n * @see https://github.com/eshaz/icecast-metadata-js\n * @copyright 2021 Ethan Halsall\n *  This file is part of icecast-metadata-stats.\n *\n *  icecast-metadata-stats free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  icecast-metadata-stats distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with this program.  If not, see <https://www.gnu.org/licenses/>\n */\n\nimport { IcecastReadableStream } from \"icecast-metadata-js\";\n\nconst noOp = () => {};\n\nconst STOPPED = \"stopped\";\nconst RUNNING = \"running\";\nconst FETCHING = \"fetching\";\n\nconst p = new WeakMap();\n\n// variables\nconst icyController = Symbol();\nconst icyFetchStatus = Symbol();\n\nconst oggController = Symbol();\nconst oggFetchStatus = Symbol();\n\nconst icestatsEndpoint = Symbol();\nconst icestatsController = Symbol();\nconst icestatsFetchStatus = Symbol();\n\nconst statsEndpoint = Symbol();\nconst statsController = Symbol();\nconst statsFetchStatus = Symbol();\n\nconst nextsongsEndpoint = Symbol();\nconst nextsongsController = Symbol();\nconst nextsongsFetchStatus = Symbol();\n\nconst sevenhtmlEndpoint = Symbol();\nconst sevenhtmlController = Symbol();\nconst sevenhtmlFetchStatus = Symbol();\n\nconst streamEndpoint = Symbol();\nconst icyMetaInt = Symbol();\nconst icyDetectionTimeout = Symbol();\nconst sources = Symbol();\nconst interval = Symbol();\nconst onStats = Symbol();\nconst onStatsFetch = Symbol();\n\nconst state = Symbol();\nconst intervalId = Symbol();\n\n// methods\nconst fetchStats = Symbol();\nconst getStreamMetadata = Symbol();\n\nexport default class IcecastMetadataStats {\n  /**\n   * @constructor\n   * @param {URL} endpoint Stream endpoint\n   * @param {object} [options] Options object\n   *\n   * @callback [options.onStats] Called when the automatic query completes\n   * @callback [options.onStatsFetch] Called when the automatic query begins\n   * @param {Array} [options.sources] List of sources to automatically query [\"icy\", \"ogg\", \"icestats\", \"stats\", \"sevenhtml\", \"nextsongs\"]\n   * @param {number} [options.interval] Time in seconds to wait between automatically queries\n   * @param {URL} [options.icestatsEndpoint] Endpoint for the `status-json.xsl` source\n   * @param {URL} [options.statsEndpoint] Endpoint for the `stats` source\n   * @param {URL} [options.nextsongsEndpoint] Endpoint for the `nextsongs` source\n   * @param {URL} [options.sevenhtmlEndpoint] Endpoint for the `7.html` source\n   * @param {number} [options.icyMetaInt] Manually sets the ICY metadata interval\n   * @param {number} [options.icyDetectionTimeout] Time in milliseconds to search for ICY metadata\n   */\n  constructor(endpoint, options = {}) {\n    const serverPath = endpoint.split(\"/\").slice(0, -1).join(\"/\");\n\n    // prettier-ignore\n    p.set(this, {\n      [streamEndpoint]: endpoint,\n      [icestatsEndpoint]: options.icestatsEndpoint || `${serverPath}/status-json.xsl`,\n      [statsEndpoint] : options.statsEndpoint || `${serverPath}/stats`,\n      [nextsongsEndpoint] : options.nextsongsEndpoint || `${serverPath}/nextsongs`,\n      [sevenhtmlEndpoint] : options.sevenhtmlEndpoint || `${serverPath}/7.html`,\n      [sources]: options.sources || [],\n      [interval]: (options.interval || 30) * 1000,\n      [onStats]: options.onStats || noOp,\n      [onStatsFetch]: options.onStatsFetch || noOp,\n      [icyMetaInt]: options.icyMetaInt,\n      [icyDetectionTimeout]: options.icyDetectionTimeout,\n      [icyController]: new AbortController(),\n      [oggController]: new AbortController(),\n      [icestatsController]: new AbortController(),\n      [statsController]: new AbortController(),\n      [nextsongsController]: new AbortController(),\n      [sevenhtmlController]: new AbortController(),\n      [state]: STOPPED,\n    });\n  }\n\n  static xml2Json(xml) {\n    const deserialize = (xml) =>\n      new DOMParser().parseFromString(xml, \"application/xml\");\n\n    const serialize = (element) => {\n      if (!element.children.length) {\n        return Number.isNaN(Number(element.innerHTML))\n          ? element.innerHTML\n          : Number(element.innerHTML);\n      }\n\n      const json = {};\n\n      for (const child of element.children) {\n        if (child.nodeName in json) {\n          if (Array.isArray(json[child.nodeName])) {\n            json[child.nodeName].push(serialize(child));\n          } else {\n            json[child.nodeName] = [json[child.nodeName], serialize(child)];\n          }\n        } else {\n          json[child.nodeName] = serialize(child);\n        }\n      }\n\n      return json;\n    };\n\n    return serialize(deserialize(xml));\n  }\n\n  /**\n   * @returns The current state [\"stopped\", \"running\", \"fetching\"]\n   */\n  get state() {\n    return p.get(this)[state];\n  }\n\n  /**\n   * @returns The generated `status-json.xsl` endpoint\n   */\n  get icestatsEndpoint() {\n    return p.get(this)[icestatsEndpoint];\n  }\n\n  /**\n   * @returns The generated `stats` endpoint\n   */\n  get statsEndpoint() {\n    return p.get(this)[statsEndpoint];\n  }\n\n  /**\n   * @returns The generated `nextsongs` endpoint\n   */\n  get nextsongsEndpoint() {\n    return p.get(this)[nextsongsEndpoint];\n  }\n\n  /**\n   * @returns The generated `7.html` endpoint\n   */\n  get sevenhtmlEndpoint() {\n    return p.get(this)[sevenhtmlEndpoint];\n  }\n\n  /**\n   * @description Starts automatically fetching stats\n   */\n  start() {\n    if (p.get(this)[state] === STOPPED) {\n      p.get(this)[state] = RUNNING;\n\n      this.fetch().then(p.get(this)[onStats]);\n\n      p.get(this)[intervalId] = setInterval(() => {\n        this.fetch().then(p.get(this)[onStats]);\n      }, p.get(this)[interval]);\n    }\n  }\n\n  /**\n   * @description Stops automatically fetching stats and cancels any inprogress stats\n   */\n  stop() {\n    if (p.get(this)[state] !== STOPPED) {\n      p.get(this)[state] = STOPPED;\n\n      clearInterval(p.get(this)[intervalId]);\n      p.get(this)[icyController].abort();\n      p.get(this)[oggController].abort();\n      p.get(this)[icestatsController].abort();\n      p.get(this)[statsController].abort();\n      p.get(this)[sevenhtmlController].abort();\n    }\n  }\n\n  /**\n   * @description Manually fetches stats from the sources passed in to the `options.sources` parameter\n   * @async\n   * @returns {object} Object containing the stats from the sources\n   */\n  async fetch() {\n    if (p.get(this)[state] !== FETCHING) {\n      const oldState = p.get(this)[state];\n\n      p.get(this)[state] = FETCHING;\n      p.get(this)[onStatsFetch](p.get(this)[sources]);\n\n      const promises = [];\n      if (p.get(this)[sources].includes(\"icestats\"))\n        promises.push(this.getIcestats());\n      if (p.get(this)[sources].includes(\"sevenhtml\"))\n        promises.push(this.getSevenhtml());\n      if (p.get(this)[sources].includes(\"stats\"))\n        promises.push(this.getStats());\n      if (p.get(this)[sources].includes(\"nextsongs\"))\n        promises.push(this.getNextsongs());\n      if (p.get(this)[sources].includes(\"icy\"))\n        promises.push(this.getIcyMetadata());\n      if (p.get(this)[sources].includes(\"ogg\"))\n        promises.push(this.getOggMetadata());\n\n      const stats = await Promise.all(promises).then((stats) =>\n        stats.reduce((acc, stat) => ({ ...acc, ...stat }), {})\n      );\n\n      p.get(this)[state] =\n        p.get(this)[state] !== FETCHING ? p.get(this)[state] : oldState;\n\n      return stats;\n    }\n  }\n\n  /**\n   * @description Fetches the data from the `/status-json.xsl` endpoint\n   * @async\n   * @returns {object} Object containing results of `/status-json.xsl`\n   */\n  async getIcestats() {\n    return this[fetchStats]({\n      status: icestatsFetchStatus,\n      endpoint: icestatsEndpoint,\n      controller: icestatsController,\n      mapper: (res) => res.json(),\n    }).then((stats) => ({ icestats: stats && stats.icestats }));\n  }\n\n  /*\n  <HTML><meta http-equiv=\"Pragma\" content=\"no-cache\"></head><body>350,1,132,1000,41,128,Dj Mixes Sety</body></html>\n  ,141,1000,50,128,Gra AutoPilot audycje Energy 2000</body></html>\n  ,27,1000,8,128,Gra Wavelogic audycje Rave With The Wave</body></html>\n  ,578,1000,233,128,youtube.com/RadioPartyOfficial</body></html>\n  ,15,1000,5,64,youtube.com/RadioPartyOfficial</body></html>\n  */\n\n  // http://wiki.winamp.com/wiki/SHOUTcast_DNAS_Server_2_XML_Reponses#Equivalent_of_7.html\n  // CURRENTLISTENERS STREAMSTATUS PEAKLISTENERS MAXLISTENERS UNIQUELISTENERS BITRATE SONGTITLE\n\n  /**\n   * @description Fetches the data from the `/7.html` endpoint\n   * @async\n   * @returns {object} Object containing results of `/7.html`\n   */\n  async getSevenhtml() {\n    return this[fetchStats]({\n      status: sevenhtmlFetchStatus,\n      endpoint: sevenhtmlEndpoint,\n      controller: sevenhtmlController,\n      mapper: async (res) =>\n        (await res.text()).match(/(.*?)<\\/body>/gi).map((s) => {\n          const stats = s\n            .match(/(<body>|,)(?<stats>.*)<\\/body>/i)\n            .groups.stats.split(\",\");\n\n          return stats.length === 7\n            ? {\n                StreamTitle: stats[6],\n                currentListeners: parseInt(stats[4]),\n                peakListeners: parseInt(stats[2]),\n                maxListeners: parseInt(stats[3]),\n                bitrate: parseInt(stats[5]),\n                status: parseInt(stats[1]),\n                serverListeners: parseInt(stats[0]),\n              }\n            : {\n                StreamTitle: stats[4],\n                currentListeners: parseInt(stats[2]),\n                peakListeners: parseInt(stats[0]),\n                maxListeners: parseInt(stats[1]),\n                bitrate: parseInt(stats[3]),\n              };\n        }),\n    }).then((sevenhtml) => ({\n      sevenhtml,\n    }));\n  }\n\n  // http://wiki.winamp.com/wiki/SHOUTcast_DNAS_Server_2_XML_Reponses#General_Server_Summary\n  /**\n   * @description Fetches the data from the `/stats` endpoint\n   * @async\n   * @returns {object} Object containing results of `/stats`\n   */\n  async getStats() {\n    return this[fetchStats]({\n      status: statsFetchStatus,\n      endpoint: statsEndpoint,\n      controller: statsController,\n      mapper: async (res) =>\n        IcecastMetadataStats.xml2Json(await res.text()).SHOUTCASTSERVER\n          .STREAMSTATS,\n    }).then((stats) => ({\n      stats,\n    }));\n  }\n\n  // http://wiki.winamp.com/wiki/SHOUTcast_DNAS_Server_2_XML_Reponses#Nextsongs\n  /**\n   * @description Fetches the data from the `/nextsongs` endpoint\n   * @async\n   * @returns {object} Object containing results of `/nextsongs`\n   */\n  async getNextsongs() {\n    return this[fetchStats]({\n      status: nextsongsFetchStatus,\n      endpoint: nextsongsEndpoint,\n      controller: nextsongsController,\n      mapper: async (res) =>\n        IcecastMetadataStats.xml2Json(await res.text()).SHOUTCASTSERVER\n          .NEXTSONGS,\n    }).then((nextsongs) => ({\n      nextsongs,\n    }));\n  }\n\n  /**\n   * @description Fetches the first ICY metadata update from the stream\n   * @async\n   * @returns {object} Object containing ICY metadata\n   */\n  async getIcyMetadata() {\n    return this[getStreamMetadata]({\n      status: icyFetchStatus,\n      endpoint: streamEndpoint,\n      controller: icyController,\n      metadataType: \"icy\",\n      headers: { \"Icy-MetaData\": 1 },\n    });\n  }\n\n  /**\n   * @description Fetches the first Ogg metadata update from the stream\n   * @async\n   * @returns {object} Object containing Ogg metadata\n   */\n  async getOggMetadata() {\n    return this[getStreamMetadata]({\n      status: oggFetchStatus,\n      endpoint: streamEndpoint,\n      controller: oggController,\n      metadataType: \"ogg\",\n    });\n  }\n\n  async [getStreamMetadata]({\n    status,\n    endpoint,\n    controller,\n    headers,\n    metadataType,\n  }) {\n    return this[fetchStats]({\n      status,\n      endpoint,\n      controller,\n      headers,\n      mapper: async (res) =>\n        new Promise((resolve) => {\n          new IcecastReadableStream(res, {\n            onMetadata: ({ metadata }) => {\n              p.get(this)[controller].abort();\n              resolve(metadata);\n            },\n            onMetadataFailed: () => {\n              p.get(this)[controller].abort();\n              resolve();\n            },\n            metadataTypes: metadataType,\n            icyMetaInt: p.get(this)[icyMetaInt],\n            icyDetectionTimeout: p.get(this)[icyDetectionTimeout],\n          }).startReading();\n        }),\n    }).then((metadata) => ({ [metadataType]: metadata }));\n  }\n\n  async [fetchStats]({ status, endpoint, controller, mapper, headers = {} }) {\n    if (!p.get(this)[status]) {\n      p.get(this)[status] = true;\n      return fetch(p.get(this)[endpoint], {\n        method: \"GET\",\n        headers,\n        signal: p.get(this)[controller].signal,\n      })\n        .then((res) => {\n          if (!res.ok) throw new Error(`HTTP Error ${res.status}`);\n          return res;\n        })\n        .then(mapper)\n        .catch((e) => {\n          if (e.name !== \"AbortError\") {\n            console.warn(`Failed to fetch ${p.get(this)[endpoint]}`, e);\n          }\n        })\n        .finally(() => {\n          p.get(this)[status] = false;\n          p.get(this)[controller] = new AbortController();\n        });\n    }\n  }\n}\n"],"sourceRoot":""}